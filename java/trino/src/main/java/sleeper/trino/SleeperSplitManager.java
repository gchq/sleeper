/*
 * Copyright 2022-2025 Crown Copyright
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package sleeper.trino;

import com.google.inject.Inject;
import io.trino.spi.connector.ConnectorSession;
import io.trino.spi.connector.ConnectorSplitManager;
import io.trino.spi.connector.ConnectorSplitSource;
import io.trino.spi.connector.ConnectorTableHandle;
import io.trino.spi.connector.ConnectorTransactionHandle;
import io.trino.spi.connector.Constraint;
import io.trino.spi.connector.DynamicFilter;

import sleeper.trino.handle.SleeperTableHandle;
import sleeper.trino.handle.SleeperTransactionHandle;
import sleeper.trino.remotesleeperconnection.SleeperConnectionAsTrino;

import static java.util.Objects.requireNonNull;

/**
 * Creates the splits which are used by the Trino framework to share the work across multiple workers. In this
 * implementation, each split reads data from a single Sleeper partition.
 * <p>
 * The split holds the details of the partition and also the details of all of the rowkey ranges which need to be
 * returned from within that partition.
 * <p>
 * The splits are generated by combining the rowkey domains from both the static filter (supplied by
 * {@link SleeperTableHandle#getTupleDomain()}) and the dynamic filter (supplied by
 * {@link DynamicFilter#getCurrentPredicate()}). Splits will not be generated until the dynamic filter has narrowed
 * completely.
 */
public class SleeperSplitManager implements ConnectorSplitManager {
    private final SleeperConnectionAsTrino sleeperConnectionAsTrino;
    private final int maxSplitBatchSize;

    @Inject
    public SleeperSplitManager(SleeperConfig sleeperConfig,
            SleeperConnectionAsTrino sleeperConnectionAsTrino) {
        requireNonNull(sleeperConfig);
        this.sleeperConnectionAsTrino = requireNonNull(sleeperConnectionAsTrino);
        this.maxSplitBatchSize = sleeperConfig.getMaxSplitBatchSize();
    }

    /**
     * Retrieve a split source to provide access to all the splits.
     *
     * @param  transactionHandle the transaction that these splits are to work under
     * @param  session           the session that these splits are to work under
     * @param  tableHandle       the table that these splits are to be generated for, which includes a static
     *                           filter
     * @param  dynamicFilter     the dynamic filter waits until it is fully-narrowed and then combined with the
     *                           static filter
     * @param  constraint        currently ignored
     * @return                   the {@link ConnectorSplitSource}
     */
    @Override
    public ConnectorSplitSource getSplits(ConnectorTransactionHandle transactionHandle,
            ConnectorSession session,
            ConnectorTableHandle tableHandle,
            DynamicFilter dynamicFilter,
            Constraint constraint) {
        return new SleeperSplitSource(
                sleeperConnectionAsTrino,
                (SleeperTransactionHandle) transactionHandle,
                (SleeperTableHandle) tableHandle,
                dynamicFilter,
                maxSplitBatchSize);
    }
}
